The main objective of this thesis was to characterize the impact of context variables and domain-specific design patterns on the performance factors of a software system. To achieve this objective we had to identify all elements related to the main objective, among them we identify the more relevant system performance factors in software systems, identify context variables that significantly influence the performance of software systems, and identify domain-specific design patterns for improving performance. This phase allowed us to produce one of the more important results for us, an SLR about the domain-specific design patterns for improving the performance.

After the identification or exploration phase, we had to select relevant system platform factors in software engineering literature related to the selected domain-specific design patterns, select relevant context variables in software systems related to performance, and select domain-specific design patterns to apply and analyse. This selection phase allowed us to achieve the first and second specific objectives proposed for this thesis, where we needed to select a set of domain-specific design patterns that address performance, and select performance factors and context variables in accordance to their impact and relevance in the performance of software systems.

Once the selection phase concluded, we designed the experiments to take measurements that make possible to characterize the impact of domain-specific design patterns and context variables on performance factors. We implemented a case study and to inject in it the measurements needed to characterize the impact of context variables and domain-specific design patterns on performance factors. The case study that we used was the sorting problem. Following this, we executed the set of experiments designed and implemented to characterize and analyse the impact of domain-specific design patterns and context variables selected over performance. In this phase, we achieve the third, fourth, and fifth specific objectives. During the analysis of the experiments, we got a set of result, we will mention those that we considered the most relevant.

\begin{itemize}
	\item Communication time is so important for the distributed environments. Depends on the configuration selected, the communication time can take between 10\% and 80\% of the total time to process a file. 
	\item As we increase the processing nodes amount, the percentage required by the communication time is increased too. However, there is not a linear relationship between the percentage of time increased by each processing node. 
	\item The communication time percentage has a strong relationship with the memory structure. The NORMA structure memory has a greater increase range than the UMA memory structure, it can be observed because no matter the design pattern always NORMA structure memory has a less communication time percentage when fewer processing nodes has the processing, but, when the processing nodes increase, it has a greater increase in the communication time percentage too than the UMA structure. Thus, with a little number of processing nodes the NORMA memory structure could be a good selection, but if we need more processing nodes, we should think of the UMA memory structure as the best option.
	\item The design pattern with more best processing times is the Fork/Join Java library, it has 275 times. The worse design pattern is the Fork/Join Design Pattern, it has 18 times. This result is very interesting due to the worse result was gotten with the distributed version of the Fork/Join Java Library. We can think that we should improve the code implementation or the strategy used to extrapolate the design pattern to a distributed environment. 
	\item The 79\% of time strategies associated with the original strategy (original strategy, Original Strategy Variation, and Fork/Join Java library) get the best processing time. This fact implies that the original strategy proposed by Juan Carlos Mu√±oz is a good way to distribute processing.
	\item The memory structure seems does not influence strongly on the original strategy variation and fork/join java library, however, in the original strategy the NORMA memory structure does not allow that it takes advantage of the distribution (see section \ref{sebsec:consolidatedData}). Leader-Followers and Fork/Join design patterns have better results in the NORMA memory structure. It suggests that the original strategy variation and fork/join java library are good options when you need to distribute the processing.
	\item  Analyzing the communication protocol, we can evidence that the fork/join java library is who takes more advantage of the ice communication protocol. the original strategy variation has a similar behaviour among the communication protocols. Leader-Followers takes more advantage of the RMI communication protocol, and Fork/Join takes more advantage of the Rest communication protocol. Both Leader-Followers and Fork/Join design patterns can not take much advantage of the Ice communication protocol.
	\item Talking about the processing nodes, the Leader-Followers and Fork/Join design patterns seems to have better results when more processing nodes are available. The other strategies have not uniform behaviour, such as we mentioned before. That is why despite these strategies give us the best results adding new processing nodes could have a contrary result of the expected.
	\item Respect to the file size we see that the behaviour is uniform, so, this variable could not affect the design patterns.
	\item In a distributed environment adding new processing nodes no guarantee that the performance could be improved. We think that this behaviour is consistent due to each time that we adding a new processing node, we are introducing latency on account of the distribution and the result merge time.
	\item  We evidence that the throughput could be calculated based on the latency, however, in a throughput gap the latency could vary until 10 times among the processing requests.
	\item When we compare the tests with the same configuration executed at 1GB (reference section \ref{sebsec:consolidatedData}) and 100MB we can verify that the relation between them is approximately 10 times.
\end{itemize}

Finally, we take advantage of the degree students thesis where they have a different study case (Carvajal IT case) and they took measurements of context variables and they used domain-specific design pattern to improve performance actually problems. We compare our results with them to achieve the sixth specific objective proposed in this thesis.